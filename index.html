<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">
<title>Portfolio</title>
<style>
  :root{
    --bg:#070a12; --ink:#eaf2ff; --mut:#bcd0ff;
    --card:rgba(12,14,24,.55); --line:rgba(255,255,255,.12);
    --accent:#8db3ff; --shadow:0 12px 40px rgba(0,0,0,.45);
  }

  html, body { margin:0; background:var(--bg); color:var(--ink); font:16px/1.55 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  .wrap { max-width: 1200px; margin: 0 auto; padding: 24px; }
  header { margin: 8px 0 16px; opacity:.95; }
  h1 { margin:0; font-weight:800; letter-spacing:.2px }
  p.lead { margin:.25rem 0 0; color:var(--mut) }

  /* Scroll section + scene window */
  #scroll3d { position: relative; height: 650vh; z-index: 0; }
  .pin {
    position: sticky; top: 0; height: 78vh; min-height: 480px; border-radius: 16px;
    border:1px solid var(--line); overflow:hidden; box-shadow: var(--shadow);
    background: radial-gradient(1200px 420px at 75% -10%, rgba(141,179,255,.12), transparent 60%), var(--bg);
    z-index: 0; /* base layer */
  }
  #webgl {
    width:100%; height:100%; display:block;
    position: relative; z-index: 0;
    pointer-events: none; /* let clicks pass through to HTML UI */
  }

  /* Vignette (visual only) */
  .vignette {
    position:absolute; inset:0; pointer-events:none; z-index:1;
    background: radial-gradient(120% 120% at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,.18) 100%);
  }

  /* ---------- Overlay & Panels: pass-through by default ---------- */

  /* Overlay floats over the scene but lets clicks pass through by default */
  .overlay{
    position:absolute; inset:0;
    display:flex; flex-direction:column; justify-content:space-between;
    z-index:2;
    pointer-events:none;
  }

  /* The empty wrapper should NOT catch clicks */
  .panels{ pointer-events:none; }

  /* Only the visible panel should be clickable, hidden ones must not block */
  .panel { pointer-events:none; }        /* default: NO clicks on hidden panels */
  .panel.show { pointer-events:auto; }   /* enable clicks only on the shown card */

  /* HUD (buttons) */
  .hud {
    pointer-events:auto; align-self:center; margin-top:12px;
    border:1px solid var(--line); background:var(--card);
    border-radius:12px; padding:8px 12px; box-shadow:var(--shadow); backdrop-filter: blur(8px);
    font-size:.95rem; display:flex; gap:.6rem; flex-wrap:wrap; align-items:center;
  }
  .badge { border:1px solid var(--line); padding:.2rem .5rem; border-radius:8px; opacity:.95; background:rgba(255,255,255,.06) }
  .jump { cursor:pointer; color:var(--ink); border:1px solid var(--line); padding:.25rem .55rem; border-radius:8px; background:rgba(255,255,255,.08); transition:transform .1s ease }
  .jump:hover { transform: translateY(-1px); }
  .sp { opacity:.85 }
  #pct { opacity:.9 }

  /* Panels */
  .panels { position:relative; width:100%; display:grid; place-items:center; margin-bottom:12px; }
  .panel {
    position:absolute; bottom:16px;
    width:min(720px, 92%); text-align:left;
    border:1px solid var(--line); background:var(--card); border-radius:14px;
    padding:14px 16px; box-shadow:var(--shadow); backdrop-filter: blur(10px);
    opacity:0; transform: translateY(10px) scale(.985); transition: opacity .35s ease, transform .35s ease;
  }
  .panel.show { opacity:1; transform:none; }
  .panel h3 { margin:.1rem 0 .35rem; letter-spacing:.2px }
  .panel p { margin:.2rem 0 0; color:#cfe0ff }
  .panel .actions { margin-top:.6rem; display:flex; gap:.5rem; flex-wrap:wrap }
  .button { text-decoration:none; color:var(--ink); border:1px solid var(--line); padding:.35rem .7rem; border-radius:10px; background:rgba(255,255,255,.08) }
  .accent { color:var(--accent) }

  footer { margin: 48px 0; text-align:center; opacity:.8 }
  a { color:var(--accent); text-decoration:none }
  a:hover{ text-decoration:underline }

  /* Tiles */
  .tile-grid {
    display: flex; justify-content: center; gap: 24px; flex-wrap: wrap;
  }
  .tile { width: 180px; height: 180px; perspective: 1000px; }
  .tile-inner { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; cursor: pointer; }
  .tile:hover .tile-inner { transform: rotateY(180deg); }
  .tile-front, .tile-back {
    position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
    border: 1px solid var(--line); border-radius: 12px; box-shadow: var(--shadow);
    display: flex; justify-content: center; align-items: center; background: var(--card);
  }
  .tile-front { color: var(--ink); }
  .tile-back { transform: rotateY(180deg); background: var(--accent); color: #fff; }
  .tile-back a { color: #fff; text-decoration: none; font-weight: bold; }

  /* Modal */
  .modal {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 9999;
  }
  .modal-content {
    background: var(--card); padding: 24px; border-radius: 12px; max-width: 800px; width: 90%;
    color: var(--ink); box-shadow: var(--shadow); text-align: left; position: relative;
  }
  .modal-content h2 { margin-top: 0; }
  .modal-close { position: absolute; top: 10px; right: 15px; font-size: 1.5rem; cursor: pointer; color: var(--mut); }

  /* Ensure sections below can sit above if needed */
  section#tiles, section#contact { position: relative; z-index: 1000; } /* above scene+overlay */
</style>

</head>
<body>
  <div class="wrap">
    <header>
      <h1 style="text-align:center">ATHARVA VIDWANS</h1>
      <h3 style="text-align:center">PORTFOLIO</h3>
    </header>

    <section id="scroll3d" aria-label="Scroll-driven 3D">
      <div class="pin">
        <canvas id="webgl"></canvas>
        <div class="vignette"></div>

        <!-- UI -->
        <div class="overlay">
          <div class="hud">
            <span class="sp">Chapters:</span>
            <button class="jump" data-target="0.00">Start</button>
            <button class="jump" data-target="0.05">About Me</button>
            <button class="jump" data-target="0.17">Undergrad</button>
            <button class="jump" data-target="0.29">Autonomous Robotic Surgery</button>
            <button class="jump" data-target="0.41">Entry into Quantum Computing</button>
            <button class="jump" data-target="0.53">Research Intern</button>
            <button class="jump" data-target="0.65">Masters</button>
            <button class="jump" data-target="0.77">PhD</button>
            <button class="jump" data-target="0.89">Resume</button>
          </div>

          <div class="panels">
            <div id="p-start"     class="panel"><h3 class="accent">Start</h3><p>Welcome aboard!! My name is Atharva Vidwans and I will take you through my life journey. Enjoy the ride!!!</p></div>
            <div id="p-about"     class="panel"><h3 class="accent">About Me</h3><p>I am a second year PhD student at UW Madison. My research is in Quantum algorithms and quantum computing. Outside my research and academics, I like solving problems and putting pieces together, sometimes elegantly, sometimes with duct tape. I build, break, and rebuild until something interesting comes out. Outside of that cycle, I write blogs, play soccer and badminton, or buried in an Agatha Christie novel (my personal favourite novel: Murder of Roger Ackroyd).</p></div>
            <div id="p-undergrad" class="panel"><h3 class="accent">Undergrad</h3><p>I completed my undergraduate degree in Mechanical Engineering, with a final-year project focused on <strong>3D printing</strong>. Studying Mechanical Engineering gave me a unique perspective on problem solving, it was during these 4 years I became fascinated by the strange and elegant laws that govern the quantum world. This was my first introduction to quantum.</p></div>
            <div id="p-robotic"   class="panel"><h3 class="accent">Autonomous Robotic Surgery</h3><p>After my undergraduate degree, I worked as a Research Intern at a startup in <strong>autonomous robotic surgery for treating kidney stones</strong> under the guidance of <strong>Rakesh Sharma</strong>. My work focused on image registration of Digitally Rendered Radiographs(DRRs), where I used Python tools of parallel processing such as Numba to accelerate DRR generation. By leveraging parallel computing, I was able to improve registration speed by nearly 300×. A detailed report of this work can be found (<a href="Files/comofi_report.pdf" target="_blank" rel="noopener noreferrer">here</a>).</p><p>Even while working in robotics, my self-study in quantum mechanics and quantum computing never stopped.</p></div>
            <div id="p-quantum"   class="panel">
              <h3 class="accent">Entry into Quantum Computing</h3>
              <p>After enough studying and tinkering in Quantum Computing, I wanted to put my curiosity to the test, so I threw myself into quantum computing competitions, breaking things, fixing them, and occasionally even solving the problem. Along the way, I earned the <strong>IBM Quantum Developer (Associate)</strong> certification (<a href="https://www.credly.com/badges/22fd159d-7d25-4988-88ff-926a45c09da3" target="_blank" rel="noopener noreferrer">here</a>). With all these competitions and hackathons, I discovered that dedication isn’t just about smooth wins, it’s about the nights spent stuck on a bug, the papers re-read three times, and the stubborn joy of refusing to give up until something finally clicks.</p>
              <p>Along the way I did few mini projects in quantum computing. Few of the projects code can be found here:
                <a href="https://github.com/Atharva-Vidwans/VQC-with-Pennylane" target="_blank" rel="noopener noreferrer">QML using variational Quantum Classifier in Pennylane</a>,
                <a href="https://github.com/Atharva-Vidwans/Payoff-optimization-in-options-using-Quantum-Amplitude-Estimation" target="_blank" rel="noopener noreferrer">Payoff optimization in Options using Quantum Amplitude Estimation</a>,
                <a href="https://github.com/Atharva-Vidwans/QUBO-formulation-of-Crop-Yield-problem" target="_blank" rel="noopener noreferrer">QUBO formulation for crop yield problem</a>.
              </p>
              <p>Articles for all these problems can be found on my medium page <a href="https://medium.com/@atharvavidwans" target="_blank" rel="noopener noreferrer">here</a>.</p>
            </div>
            <div id="p-mini"      class="panel">
              <h3 class="accent">Research Intern</h3>
              <p>I began my journey in quantum computing as a research intern under <strong>Dr. Pawel Gora</strong> at the University of Warsaw, where I worked on <strong>layering VQE and FVQE</strong> to tackle the <strong>Vehicle Routing Problem and its variants</strong>. It was an exciting challenge, my first taste of applying quantum ideas to real-world problems. I even had the chance to present this work at the <strong>13th Warsaw IT Days Conference in 2022</strong>, which was both nerve-wracking and unforgettable. The slides from that talk can be viewed <a href="https://www.informatyka.agh.edu.pl/media/uploads/kqis-55-pawel-gora-26-04-2022-slides.pdf" target="_blank" rel="noopener noreferrer">here</a>.</p>
              <p>This experience was a turning point. It convinced me that quantum computing wasn’t just a passing interest but it was the field I wanted to dive deeper into. That realization ultimately led me to pursue a Master’s program in Physics at UW–Madison, where I could continue exploring this fascinating world.</p>
            </div>
            <div id="p-ms"        class="panel"><h3 class="accent">Masters</h3><p>During my Master’s in Physics at UW–Madison, I worked under <strong>Prof. Micheline Soley</strong> and 
<strong>Prof. Shimon Kolkowitz</strong> on multiple research projects spanning quantum algorithm 
development and error correction. I investigated molecular resonances and developed a quantum 
algorithm called <strong>qDRIVE</strong>, which incorporated <strong>Complex Absorbing Potentials</strong> to 
identify resonance states. I also contributed to the design and implementation of 
<strong>Bayesian Iterative Quantum Amplitude Estimation (BIQAE)</strong>, where Bayesian inference was 
used to obtain rigorous interval estimates with far fewer measurements in applications ranging 
from finance to quantum chemistry 
(<a href="https://arxiv.org/abs/2507.23074" target="_blank" rel="noopener noreferrer">paper</a>). 
In parallel, I explored <strong>ADAPT-VQE</strong>, an adaptive ansatz construction method for ground-state 
energy estimation, analyzing its efficiency and limitations compared to traditional unitary 
coupled-cluster approaches. Additionally, I implemented simulations of <strong>surface codes</strong> to study 
error thresholds, logical qubit lifetimes, and trade-offs between code distance and realistic noise 
models 
(<a href="Files/SurfaceCodes.pdf" target="_blank" rel="noopener noreferrer">report</a>). 
Collectively, these projects gave me broad experience in algorithm design, performance analysis, 
and error mitigation strategies, preparing me to tackle both theoretical and practical challenges 
in quantum computing.</p></div>
            <div id="p-phd"       class="panel"><h3 class="accent">PhD</h3><p>Currently I am in my second year of my PhD in Quantum chemistry. I am working with Prof. Matthew Otten in Non-orthogonal Quantum Eigensolver. I am working with Double factorization and tensor hyper contraction along with BIQAE to reduce number of pauli terms scaling thus requiring even less shots and exsiting methods.</p></div>
            <div id="p-future"    class="panel"><h3 class="accent">Resume</h3><p>Click <a href="Files/Resume.pdf" target="_blank" rel="noopener noreferrer">here</a> for resume</p></div>
          </div>
        </div>
      </div>
    </section>

    <section id="tiles" style="margin:60px 0">
      <h2 style="text-align:center; margin-bottom:24px;">Selected Projects</h2>
      <div class="tile-grid">
        <div class="tile"
          data-title="BIQAE"
          data-html="We establish a unified statistical framework that underscores the crucial role statistical inference plays in Quantum Amplitude Estimation (QAE), a task essential to fields ranging from chemistry to finance and machine learning. We use this framework to harness Bayesian statistics for improved measurement efficiency with rigorous interval estimates at all iterations of Iterative Quantum Amplitude Estimation. We demonstrate the resulting method, Bayesian Iterative Quantum Amplitude Estimation (BIQAE), accurately and efficiently estimates both quantum amplitudes and molecular ground-state energies to high accuracy, and show in analytic and numerical sample complexity analyses that BIQAE outperforms all other QAE approaches considered. Both rigorous mathematical proofs and numerical simulations conclusively indicate Bayesian statistics is the source of this advantage, a finding that invites further inquiry into the power of statistics to expedite the search for quantum utility. Paper can be found <a href='https://arxiv.org/abs/2507.23074' target='_blank' rel='noopener noreferrer'>here</a>.
		  <br>Mentor: Prof. Yazhen Wang and Prof. Micheline Soley">
          <div class="tile-inner">
            <div class="tile-front">
              <h3>BIQAE</h3>
            </div>
            <div class="tile-back">
              Bayesian Iterative Quantum Amplitude Estimation
            </div>
          </div>
        </div>
        <div class="tile" data-title="qDRIVE" data-html="Many interesting problems in chemistry, from controlling the outcome of ultracold chemical
reactions collisions to autoionizing electronic states, rely on the efficient computation of resonances,
the complex-energy eigenstates of the Hamiltonian. Classical computing algorithms suffer from
the curse of dimensionality, while current quantum algorithms require prior information, such as
theta trajectories in complex scaling methods. We design a variational method using complex
absorbing potentials that can be run with a low qubit and gate count on quantum computers. We
introduce a novel metric, the“pseudovariance”, to determine the eigenstates of the non-Hermitian
Hamiltonian, and present various methods to improve the accuracy and efficiency of the algorithm
for use on near-term intermediate-scale quantum computers. More generally, the algorithm has
the capabilities to calculate the eigenvalues of non-Hermitian Hamiltonians, suggesting ultimate
impacts in parity-time reversal (PT) symmetry, optics, and nuclear physics.
<br>Mentor: Prof. Micheline Soley">
          <div class="tile-inner">
            <div class="tile-front"><h3>qDRIVE</h3></div>
            <div class="tile-back">quantum Deflated Resonance Identification Variational Quantum Eigensolver</div>
          </div>
        </div>
        <div class="tile" data-title="VRP" data-html="In this research I was working on a well know NP-Hard problem, Vehicle Routing Problem and its variants with 
		Capacity and time. We used VQE variants like Layered-VQE and Filtering-VQE. This was the <br>Mentor: Prof. Pawel Gora">
          <div class="tile-inner">
            <div class="tile-front"><h3>VPR</h3></div>
            <div class="tile-back">Vehicle Routing Problem on a Quantum Computer</div>
          </div>
        </div>
        <div class="tile" data-title="Robotic Surgery" data-html="My aim was to develop an algorithm to calculate the shift in the position and orientation of the calyx between the pre-operative CT acquisition and the intra-operative patient orientation during the kidney stone removal surgery so that it can be taken into consideration by the robot arm during puncture process.
For this I developed an algorithm, which generates the Digitally Rendered Radiograph of the input CT volume data at given angle of rotation of CT data.
After the DRR generation the registration algorithm registers CARM and DRR to find the best possible pair with least error or maximum similarity so that the exact orientation of the calyx can be found out.
Mentor: Rakesh Sharma">
          <div class="tile-inner">
            <div class="tile-front"><h3>Robotic Surgery</h3></div>
            <div class="tile-back">Autonomous Robotic Surgery for treating Kidney stones</div>
          </div>
        </div>
      </div>
    </section>
    
    <section id="contact" style="margin-top:24px;margin-bottom:60px">
      <h2>Contact</h2>
      <p style="color:#bcd0ff">EMAIL ID:
        <a href="mailto:atharvavidwans@gmail.com">atharvavidwans@gmail.com</a> |
        <a href="mailto:avidwans@wisc.edu">avidwans@wisc.edu</a>
      </p>
      <p style="color:#bcd0ff">ADDRESS: Madison, Wisconsin, US</p>
      <p style="color:#bcd0ff">PHONE: +1 (608)-895-1521</p>
      <p style="color:#bcd0ff">
        SOCIAL:   
        <a href="https://www.linkedin.com/in/atharva-vidwans-62739b169" target="_blank"><i class="fab fa-linkedin"></i></a>&nbsp;&nbsp;
        <a href="https://github.com/Atharva-Vidwans" target="_blank"><i class="fab fa-github"></i></a>&nbsp;&nbsp;
        <a href="https://medium.com/@yourusername" target="_blank"><i class="fab fa-medium"></i></a>
      </p>
    </section>
  </div>

  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
  
  <div class="modal" id="modal">
    <div class="modal-content">
      <span class="modal-close" id="modalClose">&times;</span>
      <h2 id="modalTitle">Title</h2>
      <p id="modalText">This is where more detailed information will appear.</p>
    </div>
  </div>
<script>
// Attach click to each tile
document.querySelectorAll('.tile').forEach(tile => {
  tile.addEventListener('click', (e) => {
    // If the user clicked a real link inside the tile, don't intercept
    if (e.target.closest('a')) return;

    const title = tile.dataset.title || tile.querySelector('h3')?.textContent || 'Project';
    const html  = tile.dataset.html  || 'Details coming soon.';

    document.getElementById('modalTitle').textContent = title;
    document.getElementById('modalText').innerHTML   = html;
    document.getElementById('modal').style.display   = 'flex';
  });
});

// Close button
document.getElementById('modalClose').addEventListener('click', () => {
  document.getElementById('modal').style.display = 'none';
});

// Close when clicking outside content
document.getElementById('modal').addEventListener('click', (e) => {
  if (e.target.id === 'modal') {
    document.getElementById('modal').style.display = 'none';
  }
});
</script>

<script>
(function(){
  const canvas = document.getElementById('webgl');
  const sec    = document.getElementById('scroll3d');
  const pctEl  = document.getElementById('pct');
  const spotEl = document.getElementById('spot');

  // Renderer / Scene / Camera
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 1.75)); // cap for perf
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0a1020, 0.010);

  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 4000);

  // Lighting: hemisphere + key (moon-ish)
  scene.add(new THREE.HemisphereLight(0x6f92ff, 0x0f1422, 0.35));
  const key = new THREE.DirectionalLight(0xcfd9ff, 0.9);
  key.position.set(120, 200, 80); scene.add(key);

  // Utility: round glow sprite texture
  function makeRoundSprite(size=256, color='255,255,255', inner=1, outer=0){
    const c=document.createElement('canvas'); c.width=c.height=size;
    const x=c.getContext('2d');
    const g=x.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
    g.addColorStop(0, `rgba(${color},${inner})`);
    g.addColorStop(1, `rgba(${color},${outer})`);
    x.fillStyle=g; x.fillRect(0,0,size,size);
    const t=new THREE.CanvasTexture(c);
    t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter;
    return t;
  }

  // Sky gradient dome
  const skyGeo = new THREE.SphereGeometry(3000, 32, 16);
  const skyMat = new THREE.ShaderMaterial({
    side: THREE.BackSide, depthWrite:false,
    uniforms:{ top:{value:new THREE.Color(0x162b60)}, bottom:{value:new THREE.Color(0x070a12)} },
    vertexShader:`varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
    fragmentShader:`varying vec3 vPos; uniform vec3 top; uniform vec3 bottom;
      void main(){ float h = normalize(vPos).y*0.5+0.5; gl_FragColor = vec4(mix(bottom, top, pow(h,1.3)), 1.0); }`
  });
  scene.add(new THREE.Mesh(skyGeo, skyMat));

  // Animated Nebula (camera-facing billboard)
  const nebGeo = new THREE.PlaneGeometry(3200, 1800, 1, 1);
  const nebMat = new THREE.ShaderMaterial({
    transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending,
    uniforms:{
      uTime:{value:0},
      uTintA:{value:new THREE.Color(0x214e9a)},
      uTintB:{value:new THREE.Color(0x8cabff)},
      uAlpha:{value:0.22}
    },
    vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
    fragmentShader:`
      varying vec2 vUv; uniform float uTime; uniform vec3 uTintA; uniform vec3 uTintB; uniform float uAlpha;
      float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }
      float noise(vec2 p){
        vec2 i=floor(p), f=fract(p);
        float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
      }
      float fbm(vec2 p){
        float v=0.0; float a=0.5;
        for(int i=0;i<5;i++){ v += a*noise(p); p*=2.03; a*=0.55; }
        return v;
      }
      void main(){
        vec2 uv = vUv * 3.0;
        uv.x += uTime*0.02; uv.y += sin(uTime*0.07)*0.2;
        float n = fbm(uv) * 0.9;
        vec3 col = mix(uTintA, uTintB, smoothstep(0.2,0.9,n));
        float alpha = smoothstep(0.25,0.95,n) * uAlpha;
        gl_FragColor = vec4(col, alpha);
      }`
  });
  const neb = new THREE.Mesh(nebGeo, nebMat);
  scene.add(neb);
  const NEB_DIST = 1200; // keep billboard this far in front of camera

  // Twinkling Stars (shader points)
  const STARS = 3200;
  const starGeo = new THREE.BufferGeometry();
  const starPos = new Float32Array(STARS*3);
  const starSize = new Float32Array(STARS);
  for(let i=0;i<STARS;i++){
    starPos[i*3+0] = (Math.random()-0.5)*2600;
    starPos[i*3+1] = Math.random()*1200 - 100;
    starPos[i*3+2] = (Math.random()-0.5)*2600;
    starSize[i] = 5 + Math.random()*6;
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
  starGeo.setAttribute('aSize', new THREE.BufferAttribute(starSize, 1));
  const starMat = new THREE.ShaderMaterial({
    vertexColors:false, transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
    uniforms:{ uTime:{value:0}, uTex:{value:makeRoundSprite(128, '255,255,255', 1, 0)} },
    vertexShader:`
      attribute float aSize; varying float vBlink; uniform float uTime;
      void main(){
        vBlink = 0.5 + 0.5*sin(uTime*2.0 + position.x*0.02 + position.z*0.03);
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = aSize * (300.0 / -mv.z);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader:`
      uniform sampler2D uTex; varying float vBlink;
      void main(){
        vec4 c = texture2D(uTex, gl_PointCoord);
        c.rgb *= mix(0.8, 1.4, vBlink);
        gl_FragColor = vec4(c.rgb, c.a);
      }`
  });
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // Foreground dust (parallax)
  const dustCount = 1200;
  const dustGeo = new THREE.BufferGeometry();
  const dustPos = new Float32Array(dustCount*3);
  for(let i=0;i<dustCount;i++){
    dustPos[i*3+0] = (Math.random()-0.5)*1600;
    dustPos[i*3+1] = Math.random()*400 - 60;
    dustPos[i*3+2] = (Math.random()-0.5)*1600;
  }
  dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
  const dustMat = new THREE.PointsMaterial({
    map: makeRoundSprite(64, '180,220,255', 0.9, 0),
    color: 0xaed1ff, size: 3.0, sizeAttenuation:true, transparent:true, depthWrite:false, opacity:0.35,
    blending: THREE.AdditiveBlending
  });
  const dust = new THREE.Points(dustGeo, dustMat);
  dust.position.z = -50;
  scene.add(dust);

  // Shooting stars (rare streaks)
  const streakGroup = new THREE.Group(); scene.add(streakGroup);
  function spawnStreak(){
    const geom = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-18)
    ]);
    const mat = new THREE.LineBasicMaterial({ color: 0x9ecbff, transparent:true, opacity:1 });
    const line = new THREE.Line(geom, mat);
    line.position.set((Math.random()-0.5)*800, Math.random()*180+40, camera.position.z - 200);
    line.userData.v = new THREE.Vector3((Math.random()-0.5)*0.8, -(Math.random()*0.2+0.1), - (Math.random()*2.0+2.5));
    line.userData.life = 1.2;
    streakGroup.add(line);
  }
  let streakTimer = 0;

  // Path & waypoints
  const pts = [
    new THREE.Vector3(  0,  8,   70),
    new THREE.Vector3( 24, 12,   20),
    new THREE.Vector3( -6, 16,  -25),
    new THREE.Vector3(-34, 14,  -70),
    new THREE.Vector3(-10, 12, -110),
    new THREE.Vector3( 36, 10, -150),
    new THREE.Vector3( 14, 12, -190),
    new THREE.Vector3(-28, 11, -235),
    new THREE.Vector3(-12, 14, -285),
    new THREE.Vector3( 22, 12, -330)
  ];
  const curve = new THREE.CatmullRomCurve3(pts, false, 'catmullrom', 0.18);

  // Ribbon tube
  const T_END = 0.90;                              // last planet's t
  const SAMPLES = 200;
  const subPts = [];
  for (let i = 0; i <= SAMPLES; i++) {
    const t = (i / SAMPLES) * T_END;
    subPts.push(curve.getPointAt(t));
  }
  const subCurve = new THREE.CatmullRomCurve3(subPts, false, 'catmullrom', 0.18);
  const tube = new THREE.TubeGeometry(subCurve, Math.ceil(320 * T_END), 0.35, 8, false);
  const ribbon = new THREE.Mesh(
    tube,
    new THREE.MeshBasicMaterial({ color:0x5c88ff, transparent:true, opacity:0.18 })
  );
  scene.add(ribbon);

  // Planets + rings + halos
  function makePlanetTexture(size = 512, hue = 210) {
    const c = document.createElement('canvas'); c.width = c.height = size;
    const ctx = c.getContext('2d');
    ctx.fillStyle = `hsl(${hue},45%,32%)`; ctx.fillRect(0, 0, size, size);
    const img = ctx.createImageData(size, size); const d = img.data;
    const h = hue/360;
    const h2rgb = t => { if (t < 0) t += 1; if (t > 1) t -= 1;
      if (t < 1/6) return t*6; if (t < 1/2) return 1; if (t < 2/3) return (2/3 - t)*6; return 0; };
    for (let y = 0; y < size; y++) {
      const v = (y/size)*2 - 1;
      const pole = 0.85 + 0.15*(1 - Math.abs(v));
      for (let x = 0; x < size; x++) {
        const u = (x/size) * Math.PI * 2.0;
        const b1 = Math.sin(u + 1.6*Math.sin(1.2*v));
        const b2 = Math.sin(u*2.3 + 0.9*v + 0.8*Math.sin(2.1*v));
        const b3 = Math.sin(u*3.7 + 1.5*v + 0.5*Math.sin(1.7*v));
        const n  = 0.5*(b1*0.55 + b2*0.3 + b3*0.15) + 0.5;
        const sat = 45 + Math.round(n*28);
        const lig = Math.round((30 + n*42) * pole);
        const s = sat/100, l = lig/100;
        const q = l < 0.5 ? l*(1+s) : l + s - l*s;
        const p = 2*l - q;
        const r = Math.round((p + (q-p)*h2rgb(h + 1/3))*255);
        const g = Math.round((p + (q-p)*h2rgb(h      ))*255);
        const b = Math.round((p + (q-p)*h2rgb(h - 1/3))*255);
        const i = (y*size + x)*4;
        d[i+0]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255;
      }
    }
    for (let y = 0; y < size; y++) {
      const i0 = (y*size + 0)*4;
      const i1 = (y*size + (size-1))*4;
      d[i1+0]=d[i0+0]; d[i1+1]=d[i0+1]; d[i1+2]=d[i0+2]; d[i1+3]=255;
    }
    ctx.putImageData(img, 0, 0);
    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.generateMipmaps = true;
    tex.minFilter = THREE.LinearMipMapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.offset.x = -0.5 / size;
    tex.repeat.x = size / (size - 1);
    return tex;
  }

  const planetGeo = new THREE.SphereGeometry(2.2, 48, 32);
  const halos = [];
  const rings = [];
  const planets = [];
  const PLANET_TS = [0.05, 0.17, 0.29, 0.41, 0.53, 0.65, 0.77, 0.89];

  PLANET_TS.forEach((t, i) => {
    const p = curve.getPointAt(t);
    const hue = 200 + i * 18;
    const tex = makePlanetTexture(512, hue);

    const planet = new THREE.Mesh(
      planetGeo,
      new THREE.MeshStandardMaterial({
        map: tex,
        roughness: 0.7,
        metalness: 0.0,
        emissive: new THREE.Color(0x000000),
        envMapIntensity: 0.3
      })
    );
    planet.position.copy(p);
    planet.userData.spin = 0.002 + Math.random() * 0.002;

    const scale = 1 + (Math.sin(i * 1.3) * 0.25);
    planet.scale.setScalar(scale);

    scene.add(planet);
    planets.push(planet);

    if (i % 2 === 1) {
      const ringGeo = new THREE.RingGeometry(3.2 * scale, 4.6 * scale, 64, 1);
      const ringMat = new THREE.MeshBasicMaterial({
        color: 0x7aa0ff,
        transparent: true,
        opacity: 0.18,
        side: THREE.DoubleSide
      });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.copy(p);
      ring.rotation.x = Math.PI / 2.1;
      scene.add(ring);
      rings.push(ring);
    }

    const halo = new THREE.Sprite(
      new THREE.SpriteMaterial({
        map: makeRoundSprite(512, '120,170,255', 0.14, 0),
        color: 0x7aa0ff,
        transparent: true,
        depthWrite: false,
        opacity: 0.85,
        blending: THREE.AdditiveBlending
      })
    );
    halo.scale.set(26 * scale, 26 * scale, 1);
    halo.position.copy(p);
    scene.add(halo);
    halos.push({ halo, base: 26 * scale + Math.random() * 6 });
  });

  // Camera frame along path
  function getCameraFrame(t){
    const p = curve.getPointAt(t);
    const ahead = curve.getPointAt(Math.min(1, t + 0.02));
    const dir = ahead.clone().sub(p).normalize();
    const up = new THREE.Vector3(0,1,0);
    const eye = p.clone().add(new THREE.Vector3(0, 3.2, 0));
    return { position: eye, target: p.clone().add(dir).setY(eye.y - 0.1), up };
  }

  // Resize
  function onResize(){
    const rect = canvas.getBoundingClientRect();
    const w = rect.width || canvas.parentElement.clientWidth;
    const h = rect.height || canvas.parentElement.clientHeight;
    renderer.setSize(w, h, false);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  onResize(); window.addEventListener('resize', onResize);

  // Scroll progress
  function scrollProgress(){
  const sc = window.scrollY || window.pageYOffset;
  const top = sec.offsetTop;
  const vh = window.innerHeight;
  const span = sec.offsetHeight - vh;
  if (span <= 0) return 0;
  const raw = Math.max(0, Math.min(1, (sc - top) / span));
  return raw * T_END; // cap at last planet
}

  const PANELS = [
    { id:'p-start',     t:0.00 },
    { id:'p-about',     t:0.05 },
    { id:'p-undergrad', t:0.17 },
    { id:'p-robotic',   t:0.29 },
    { id:'p-quantum',   t:0.41 },
    { id:'p-mini',      t:0.53 },
    { id:'p-ms',        t:0.65 },
    { id:'p-phd',       t:0.77 },
    { id:'p-future',    t:0.89 }
  ];
  const panelEls = Object.fromEntries(PANELS.map(p => [p.id, document.getElementById(p.id)]));

  function setPanelVisibility(t){
    let nearest = PANELS[0], best = 9;
    for (const p of PANELS) {
      const d = Math.abs(t - p.t);
      if (d < best){ best = d; nearest = p; }
    }
    for (const p of PANELS) {
      panelEls[p.id]?.classList.toggle('show', p.id === nearest.id);
    }
  }

  // Animate
  let tCurrent = 0, time=0;
  function animate(){
    requestAnimationFrame(animate);
    const tTarget = scrollProgress();
    tCurrent += (tTarget - tCurrent) * 0.08;
    time += 0.016;

    // Move billboard nebula in front of camera and face it
    neb.position.copy(camera.position)
      .add(new THREE.Vector3(0,0,-NEB_DIST).applyQuaternion(camera.quaternion));
    neb.quaternion.copy(camera.quaternion);
    nebMat.uniforms.uTime.value = time;

    // Subtle scene motion
    stars.rotation.y += 0.00025;
    dust.rotation.y  += 0.00015;

    // Star twinkle time
    starMat.uniforms.uTime.value = time;

    // Halo pulsing & planet spin
    for(const h of halos){
      h.halo.scale.setScalar( h.base + Math.sin(time*1.2)*0.8 );
    }
    for(const p of planets){ p.rotation.y += p.userData.spin; }

    const frame = getCameraFrame(tCurrent);
    camera.position.copy(frame.position);
    camera.up.copy(frame.up);
    camera.lookAt(frame.target);

    setPanelVisibility(tCurrent);
    if (pctEl) pctEl.textContent = Math.round(tCurrent*100)+'%';

    renderer.render(scene, camera);
  }
  requestAnimationFrame(animate);

  // Init camera
  const f0 = getCameraFrame(0);
  camera.position.copy(f0.position); camera.lookAt(f0.target);

  // Jump buttons
  function scrollToT(t){
  const top = sec.offsetTop;
  const vh = window.innerHeight;
  const span = sec.offsetHeight - vh;
  // map desired t in [0, T_END] onto the full scroll span
  const clamped = Math.max(0, Math.min(T_END, t));
  const y = top + (clamped / T_END) * span;
  window.scrollTo({ top: y, behavior: 'smooth' });
}
  document.querySelectorAll('.jump').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const t = parseFloat(btn.dataset.target || '0');
      scrollToT(t);
    });
  });
})();
</script>
</body>
</html>


